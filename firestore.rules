/**
 * Core Philosophy: This ruleset enforces a Role-Based Access Control (RBAC) model
 * with three primary roles: Customer, Stylist, and Admin. Admins have broad
 * permissions across the system, while Customers and Stylists have strict
 * ownership-based access to their personal data and appointments. The existence of a
 * document in the `/roles_admin/{uid}` collection grants a user admin privileges.
 *
 * Data Structure: The data is segregated by role and ownership. Customer and
 * Stylist data, including their respective views of appointments, are stored in
 * user-specific paths (e.g., `/customers/{userId}`). A separate, denormalized
 * collection, `/admin_appointments`, provides a centralized view for the admin
 * dashboard. Publicly accessible data like salon services is stored in a top-level
 * `/services` collection.
 *
 * Key Security Decisions:
 * - Admin Role: A user is considered an admin if a document with their UID exists
 *   in the `/roles_admin` collection. This provides a simple and secure way to
 *   manage elevated privileges.
 * - User Data Isolation: Customers and Stylists are strictly confined to their
 *   own data trees. Users cannot list or view profiles of other users (except for
 *   stylist profiles, which are public to signed-in users).
 * - Denormalization for Security: Appointment data is denormalized into three
 *   separate locations (`/customers/...`, `/stylists/...`, `/admin_appointments/...`) to
 *   ensure that security rules for each role are simple, performant, and do not
 *   require slow, cross-collection `get()` calls.
 * - Public vs. Private: Public data (like `/services`) is explicitly marked as
 *   readable by anyone. All other collections require authentication, and most
 *   require specific ownership or admin rights.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user is an administrator by checking for
     * the custom claim 'admin' on the auth token.
     */
    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the foundation of the ownership model.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Verifies that the document being operated on already exists.
     * Crucial for secure update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership and existence checks for update/delete operations.
     */
    function isOwnerOfExistingDoc(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    // --------------------------------------------------------------------
    // Customer Data Rules
    // --------------------------------------------------------------------

    /**
     * @description Manages customer profiles. Only the customer themselves or an
     *              admin can read or write their own profile. Listing all
     *              customers is restricted to admins.
     * @path /customers/{customerId}
     * @allow (create) A new user (auth.uid: 'user123') creates their own profile at `/customers/user123`.
     * @deny (get) A user (auth.uid: 'user456') tries to read another user's profile at `/customers/user123`.
     * @deny (list) A non-admin user tries to list all documents in the `/customers` collection.
     * @principle Enforces self-creation and document ownership for user profiles.
     */
    match /customers/{customerId} {
      allow get: if isOwner(customerId) || isAdmin();
      allow list: if isAdmin();
      allow create: if (isOwner(customerId) || isAdmin()) && request.resource.data.id == customerId;
      allow update: if (isOwnerOfExistingDoc(customerId) || isAdmin()) && request.resource.data.id == resource.data.id;
      allow delete: if isOwnerOfExistingDoc(customerId) || isAdmin();
    }

    /**
     * @description Manages appointments from a customer's perspective. A customer
     *              can only access appointments within their own document tree.
     * @path /customers/{customerId}/appointments/{appointmentId}
     * @allow (list) A logged-in customer (auth.uid: 'user123') lists their own appointments at `/customers/user123/appointments`.
     * @deny (get) A user ('user456') tries to get an appointment for another user ('user123').
     * @principle Restricts access to a user's own data subcollections.
     */
    match /customers/{customerId}/appointments/{appointmentId} {
      allow get: if isOwner(customerId) || isAdmin();
      allow list: if isOwner(customerId) || isAdmin();
      allow create: if (isOwner(customerId) || isAdmin()) && request.resource.data.customerId == customerId;
      allow update: if (isOwnerOfExistingDoc(customerId) || isAdmin()) && request.resource.data.customerId == resource.data.customerId;
      allow delete: if isOwnerOfExistingDoc(customerId) || isAdmin();
    }

    // --------------------------------------------------------------------
    // Stylist Data Rules
    // --------------------------------------------------------------------

    /**
     * @description Manages stylist profiles. Profiles are publicly visible to any
     *              signed-in user to allow for browsing. Only the stylist
     *              themselves or an admin can modify a profile.
     * @path /stylists/{stylistId}
     * @allow (list) Any authenticated user can list all stylists.
     * @allow (update) A stylist ('stylistABC') updates their own profile at `/stylists/stylistABC`.
     * @deny (delete) A stylist ('stylistABC') tries to delete their own profile; only admins can.
     * @principle Combines public read access with owner-only writes for profile management.
     */
    match /stylists/{stylistId} {
      allow get: if true;
      allow list: if true;
      allow create: if (isOwner(stylistId) || isAdmin()) && request.resource.data.id == stylistId;
      allow update: if (isOwnerOfExistingDoc(stylistId) || isAdmin()) && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Manages appointments from a stylist's perspective. A stylist can
     *              only view appointments within their own schedule. All write
     *              operations are restricted to admins to maintain data integrity.
     * @path /stylists/{stylistId}/appointments/{appointmentId}
     * @allow (get) A stylist ('stylistABC') views one of their appointments.
     * @deny (create) A stylist ('stylistABC') tries to create a new appointment for themselves.
     * @principle Enforces read-only access for owners, with writes restricted to admins.
     */
    match /stylists/{stylistId}/appointments/{appointmentId} {
      allow get: if isOwner(stylistId) || isAdmin();
      allow list: if isOwner(stylistId) || isAdmin();
      allow create: if isAdmin() && request.resource.data.stylistId == stylistId;
      allow update: if isAdmin() && isExistingDoc() && request.resource.data.stylistId == resource.data.stylistId;
      allow delete: if isAdmin() && isExistingDoc();
    }

    // --------------------------------------------------------------------
    // Public & Admin Data Rules
    // --------------------------------------------------------------------

    /**
     * @description Manages the salon's services. This data is public for any client
     *              to read, but can only be created, updated, or deleted by admins.
     * @path /services/{serviceId}
     * @allow (get) An anonymous user reads the details of a service.
     * @deny (create) A non-admin user tries to add a new service.
     * @principle Implements a public-read collection with admin-only write access.
     */
    match /services/{serviceId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin() && request.resource.data.id == serviceId;
      allow update: if isAdmin() && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin() && isExistingDoc();
    }
    
    /**
     * @description Manages the salon's gallery images. This data is public for any client
     *              to read, but can only be created, updated, or deleted by admins.
     * @path /gallery/{imageId}
     * @allow (get) An anonymous user reads an image from the gallery.
     * @deny (create) A non-admin user tries to add a new image.
     * @principle Implements a public-read collection with admin-only write access.
     */
    match /gallery/{imageId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description A centralized collection of all appointments, intended for use
     *              by the admin dashboard. Access is strictly limited to admins
     *              via a custom claim.
     * @path /admin_appointments/{appointmentId}
     * @allow (list) An admin user lists all appointments for the dashboard.
     * @deny (get) Any non-admin user tries to read an appointment from this collection.
     * @principle Enforces a strictly admin-only access pattern for a sensitive data collection.
     */
    match /admin_appointments/{docId} {
      allow read, write: if request.auth != null && request.auth.token.admin == true;
    }

    /**
     * @description Manages admin roles. The existence of a document in this
     *              collection grants a user admin privileges throughout the app.
     *              Only existing admins can modify this collection.
     * @path /roles_admin/{uid}
     * @allow (get) if isAdmin();
     * @allow list: if isAdmin();
     * @allow create: if isOwner(uid) && resource.data.size() == 0;
     * @allow update: if isAdmin() && isExistingDoc();
     * @allow delete: if isAdmin() && isExistingDoc();
    }
  }
}

    